
一、五级流水线和各个模块

IF: 取指
    根据PC从存储器取出指令，这里主要是控制PC产生逻辑，取指令的功能交由top层来完成
    第一种情况是 PC + 4
    第二种情况是 PC = JMP

ID: 译码
    将inst进行翻译，得到：指令类型(R,S,I,B,U,J); 操作码[6:2]; 功能码funct3,funct7；寄存器rs1,rs2,rsd；带符号扩赞的立即数imm
    对于寄存器rs1,rs2，送出寄存器索引，经过top层转送给RegFile，然后RegFile取出数据再回送到ID模块

EX: 执行
    译码后所需要进行的计算类型已知，并且从RegFile中得到了所需的操作数，则可以运算。
    执行结果一般都需要写入寄存器，转去WB模块

MEM: 访存
    包括存储器读取或写入两个过程。
    如果是存储器读取，还需要WB模块

WB: 写回
    将指令执行的结果写回RegFile。
    如果是普通运算指令，结果来自于EX阶段；
    如果是存储器读取指令，结果来自于MEM结果。

RegFile: 寄存器文件
    支持两读一写，时钟上升沿出发，一个周期即可完成

SimTop: 顶层
    连接了上述几个模块的输出输出接口

ram_1w2r: 一写两读的存储器访问接口
    后期，需要把指令读取、数据读取、数据写入等整合到一起，防止数据流阻塞，
    也方便AXI4总线接入。

二、几种数据流
load
    IF -> ID -> MEM read -> WB

store
    IF -> ID -> MEM write

other
    IF -> ID -> EX -> WB

三、控制时序

        2     3     4     5     6     7
add     IF    ID    EX          WB    CMT
store   IF    ID          MEM         CMT
load    IF    ID          MEM   WB    CMT


附录：
1. verilog中的一些常用语法现象
a. wire(线网) 与 reg(寄存器) 类型
  线网与实际中的电线类似，其数值只能通过连续赋值，由赋值符右侧连接的驱动源决定。
  线网在初始化之前为x。若未接驱动源，其值为z。
  模块中，未标注类型时默认为wire。需要考虑是否加上reg关键字。
  寄存器可以保存当前的值，直到另一个数值被赋给它。保持当前数值的过程中，不需要驱动源的作用。
  寄存器若未赋值，初始为x。
  Verilog中的寄存器类型变量与真实的寄存器硬件不同，它时一个储存数值的变量。
  在过程块（initial过程或always过程）中对变量赋值，该变量必须是寄存器类型。
  关于线网与寄存器类型的选择：
    在过程块中的变量只能是寄存器类型；
    连续赋值的对象只能是线网类型；
b. wire、reg的连续赋值
  不含时序的组合逻辑部分可以使用线网的连续赋值描述
    wire out; assign out = in1;
  reg也可以使用assign连续赋值，但实际上不可综合，可以另外设置一个wire类型来赋值
c. reg的过程赋值
  有两种赋值运算，阻塞赋值（blocking assignment），运算符为=，非阻塞赋值（non-...），运算符为 <=。
  顺序代码块中使用阻塞赋值，则这一句没有执行完，后面的语句不会执行；
  顺序代码块中使用非阻塞赋值，则这些语句是同时执行，因此后一个语句所用到的是前面一个语句的执行前变量的数值。例如，带有两个正反输出端的简单范例：
    always @ (negedge reset or posedge clk) begin
      a <= b;
      b <= a;
    end
  其中，a和b会交换数值。
d. 两种过程
  always是过程循环执行；initial过程只执行一次。

2. always和assign的区分
(1)、语法定义
assign，连续赋值。always，敏感赋值。
连续赋值，就是无条件全等。敏感赋值，就是有条件相等。
assign的对象是wire，always的对象是reg。这就是语法约束。
(2)、功能差异
assign对应电路下连线操作。always对应插入敏感控制连线。
这里容易混淆的就是assign综合的一定是组合电路，但是always综合的不一定是时序电路。
always的敏感列表使用*号就可以等效综合为组合电路。如果使用的是电平触发，也使会综合成相应的组合电路。只有出现边沿触发时，才会综合成时序电路。
而时序电路，基础就是时钟和使能两个关键信号。时钟在always模块中不再出现（时钟信号在敏感信号作用下的值一直相等，没有使用在内部的意义，当然也可以转化后使用）。
而对于使能信号，则是会有一个if判断语句，而且处于第一优先级。这就是异步复位。如果不在敏感列表而处于第一优先级，则是同步复位信号。
(3)、总结
从上面的描述可以看到：always可以实现两种电路，是不是可以不用assign来实现设计？理论上可以，但是会加大设计的难度。
首先要明确的是，always只能对reg变量赋值，这导致wire变量赋值困难。如果没有assign，每个wire变量都要加入一个reg缓冲。
可以简单理解：开始时只有always，可以实现基本的功能，然后将其中的组合逻辑提取出来构成assign。
同时引入了wire。也就是assign是always的补充（只是方便理解，没有根据）。
(4)、编程技巧
初期使用 always @(*) 可以达到组合逻辑的效果，后期再考虑assign方式。
  always @(*)能综合成组合逻辑电路的条件是，不要形成Latch，即 else, default 都要补全。
如果需要时序逻辑电路， always @(posedge clk)
如果是异步复位，则将clk、ena/clr信号都放入敏感列表；
如果是同步复位，则不加入敏感列表，而是放在第一个if语句中。

3. am-kernels/test/cpu-tests 测试记录
已通过：
add add-longlong fact goldbach ifelse leap-year load-store
matrix-mul mul-longlong prime shuixianhua sub-longlong
switch to-lower-case wanshu bit

未通过：
bubble-sort
div
fib
hello-str
max
min3
mov
movsx
pacal
quick-sort
recursion
select-sort
shift
string
sum
unalign