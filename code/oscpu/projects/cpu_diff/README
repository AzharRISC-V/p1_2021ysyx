
一、五级流水线和各个模块

IF: 取指
    根据PC从存储器取出指令，这里主要是控制PC产生逻辑，取指令的功能交由top层来完成
    第一种情况是 PC + 4
    第二种情况是 PC = JMP

ID: 译码
    将inst进行翻译，得到：指令类型(R,S,I,B,U,J); 操作码[6:2]; 功能码funct3,funct7；寄存器rs1,rs2,rsd；带符号扩赞的立即数imm
    对于寄存器rs1,rs2，送出寄存器索引，经过top层转送给RegFile，然后RegFile取出数据再回送到ID模块

EX: 执行
    译码后所需要进行的计算类型已知，并且从RegFile中得到了所需的操作数，则可以运算。
    执行结果一般都需要写入寄存器，转去WB模块

MEM: 访存
    包括存储器读取或写入两个过程。
    如果是存储器读取，还需要WB模块

WB: 写回
    将指令执行的结果写回RegFile。
    如果是普通运算指令，结果来自于EX阶段；
    如果是存储器读取指令，结果来自于MEM结果。

RegFile: 寄存器文件
    支持两读一写，时钟上升沿出发，一个周期即可完成

SimTop: 顶层
    连接了上述几个模块的输出输出接口

ram_1w2r: 一写两读的存储器访问接口
    后期，需要把指令读取、数据读取、数据写入等整合到一起，防止数据流阻塞，
    也方便AXI4总线接入。

二、几种数据流
load
    IF -> ID -> MEM read -> WB

store
    IF -> ID -> MEM write

other
    IF -> ID -> EX -> WB

三、控制时序

        2     3     4     5     6     7
add     IF    ID    EX          WB    CMT
store   IF    ID          MEM         CMT
load    IF    ID          MEM   WB    CMT


附录：
1. verilog中的一些常用语法现象
a. wire(线网) 与 reg(寄存器) 类型
  线网与实际中的电线类似，其数值只能通过连续赋值，由赋值符右侧连接的驱动源决定。
  线网在初始化之前为x。若未接驱动源，其值为z。
  模块中，未标注类型时默认为wire。需要考虑是否加上reg关键字。
  寄存器可以保存当前的值，直到另一个数值被赋给它。保持当前数值的过程中，不需要驱动源的作用。
  寄存器若未赋值，初始为x。
  Verilog中的寄存器类型变量与真实的寄存器硬件不同，它时一个储存数值的变量。
  在过程块（initial过程或always过程）中对变量赋值，该变量必须是寄存器类型。
  关于线网与寄存器类型的选择：
    在过程块中的变量只能是寄存器类型；
    连续赋值的对象只能是线网类型；
b. wire、reg的连续赋值
  不含时序的组合逻辑部分可以使用线网的连续赋值描述
    wire out; assign out = in1;
  reg也可以使用assign连续赋值，但实际上不可综合，可以另外设置一个wire类型来赋值
c. reg的过程赋值
  有两种赋值运算，阻塞赋值（blocking assignment），运算符为=，非阻塞赋值（non-...），运算符为 <=。
  顺序代码块中使用阻塞赋值，则这一句没有执行完，后面的语句不会执行；
  顺序代码块中使用非阻塞赋值，则这些语句是同时执行，因此后一个语句所用到的是前面一个语句的执行前变量的数值。例如，带有两个正反输出端的简单范例：
    always @ (negedge reset or posedge clk) begin
      a <= b;
      b <= a;
    end
  其中，a和b会交换数值。
d. 两种过程
  always是过程循环执行；initial过程只执行一次。

