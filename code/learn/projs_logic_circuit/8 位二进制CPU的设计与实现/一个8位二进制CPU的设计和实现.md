## Logical Circuit 软件

- 软件官网及介绍

  https://logiccircuit.org

  Version 2.21.01.10 released.
  14 January 2021

- 软件使用

  - 快捷键
    - 模拟开始：Ctrl + W
  - 技巧
    - 新增电路，修改电路 Name,Notation
    - Select Free Wires 选择没有连接的线。
    - 与门、非门等的封装（非常简单）
    - 连线时有折线，需要点击量词鼠标。
    - 连线交叉位置，先选中一条线，然后按住 Alt，点击焦点即可增加节点。

## 一个 8 位二进制 CPU 的设计和实现

1.  简介

    - B 站视频地址

      https://space.bilibili.com/491131440/channel/detail?cid=163546

      https://www.bilibili.com/video/BV1W5411p7Ax/?spm_id_from=autoNext

2.  演示 LED 电路，器件封装

3.  半加器

    - 真值表

    | A   | B   | S   | C   |
    | --- | --- | --- | --- |
    | 0   | 0   | 0   | 0   |
    | 0   | 1   | 1   | 0   |
    | 1   | 0   | 1   | 0   |
    | 1   | 1   | 0   | 1   |

    - 逻辑公式
      $$
       \begin{aligned}
       S =& \overline{A} B + A \overline{B} \\
       C =& AB
       \end{aligned}
      $$

4.  全加器

    - 多种实现方法
    - 利用查找表的方式
    - ROM (3 地址，2 数据)

5.  补码与减法

    - 1 位取反器

      - EN 控制是否取反，I 是输入，O 是输出

      - 真值表

      | EN  | I   | O   |
      | --- | --- | --- |
      | 0   | 0   | 0   |
      | 0   | 1   | 1   |
      | 1   | 0   | 1   |
      | 1   | 1   | 0   |

      - 其实就是异或门

    - 8 位取反器

       * 减法进位真值表
    
      | CI(进位输入 & 是否减法标志) | CO(进位输出) | O（实际输出） |
      | --------------------------- | ------------ | ------------- |
      | 0                           | 0            | 0             |
      | 0                           | 1            | 1             |
      | 1                           | 0            | 0             |
      | 1                           | 1            | 0             |

      含义：CI = 0，加法电路，此时，CO有效。CI=1，减法电路，此时，CO无效。

      公式：

      $$
      \begin{aligned}
        O = \overline{CI} ~ CO
        \end{aligned}
      $$

6.  七段十六进制数码管

    - Excel 中的转换公式

      = DEC2HEX(C2 _ 64 + D2 _ 32 + E2 _ 16 + F2 _ 8 + G2 _ 4 + H2 _ 2 + I2)

7.  七段十进制数码管

    - 继续用 ROM，将 8bit 输入，转换为 3x4bit 的输出

    - python 写一个生成 dec 到 hex 的脚本

      ```
      执行
      $ python -u "1.py"
      ```

    - 2 选 1 选择器

      | EN  | A   | B   | OUT |
      | --- | --- | --- | --- |
      | 0   |     | x   | A   |
      | 1   | x   |     | B   |

      $ OUT = \overline{EN}A + EN~B $

8.  R-S 触发器（Flip-Flop）

    - 构造：两个或非门，各自输出再接入另一个的输入端。

    - 真值表

      | Reset | Set | Q   | Q'  |
      | ----- | --- | --- | --- |
      | 0     | 0   | Q   | Q'  |
      | 0     | 1   | 1   | 0   |
      | 1     | 0   | 0   | 1   |
      | 1     | 1   | 0   | 0   |

    - 作用：当 Reset、Set 同时为 1 时，无效；同时为 0 时，保持上次状态；不同时可以设置或清除。

9.  D 触发器

    - 初衷：改进 R-S 触发器，不希望看到输出同时为 0 的无效状态，也就是确保 R/S 端不同。
    - 方法：输入：EN 和 D，输出：O。当 EN 为 0 时，O 为上次值；当 EN 为 1 时，O 为 D 的值。

10. D 边沿触发器：

    - 输入：D/CLK, 输出：O。
    - 上升沿版本：当 CLK 上升沿时，D 送给 O。平时没有变化
    - 设计初衷：上升沿送出数据，其余时间做其他准备工作。可能是为了时序同步。

    - R-S 触发器（改进版），增加了初始设定（CLR、PreSet），可以预设和清零。

11. T 触发器和行波计数器：

    - 跑马灯的例子，RESET 需要快速的置位一次。

12. 三态门和寄存器

    * D边沿触发器，制作字节存储器
    * 加上三态门，控制读写，得到寄存器

13. 三八译码器和存储器组织

    * 三八译码器

      * 真值表

        |  A2  |  A1  |  A0  | O7   |  O6  |  O5  |  O4  |  O3  |  O2  |  O1  |  O0  |
        | :--: | :--: | :--: | ---- | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
        |  0   |  0   |  0   |      |      |      |      |      |      |      |  1   |
        |  0   |  0   |  1   |      |      |      |      |      |      |  1   |      |
        |  0   |  1   |  0   |      |      |      |      |      |  1   |      |      |
        |  0   |  1   |  1   |      |      |      |      |  1   |      |      |      |
        |  1   |  0   |  0   |      |      |      |  1   |      |      |      |      |
        |  1   |  0   |  1   |      |      |  1   |      |      |      |      |      |
        |  1   |  1   |  0   |      |  1   |      |      |      |      |      |      |
        |  1   |  1   |  1   | 1    |      |      |      |      |      |      |      |

      * 逻辑表达式

        $ O_0 = \overline{A2}~\overline{A1}~\overline{A0}$

        $ O_1 = \overline{A2}~\overline{A1}~{A0}$

        ...

    * 8x1存储器：可存储8个字节（共8比特位）。

      * 存储器单元的单位：
        * B: 字节 byte：8位
        * H: 半字 half word：16位
        * W: 字 word：32位
        * D: 双字 double word：64位

14. 存储器扩展

    * 位扩展与字扩展：
      * 位扩展：增加存储器中的字长（数据线增加，地址线不变）。
      * 字扩展：增加存储器中字的数量（地址线增加，数据线不变）。
    * 位扩展：将两个 8x1 存储器扩展为16x1。地址线仍然是3位，数据线由8变为16。可存储8个半字。
    * 字扩展：将两个 8x1 存储器扩展为 8x2。地址线增加为4位，数据线还是8位。可存储16个字节。最高位地址线用来片选（高位交叉编址）；或者最低位也可以（低位交叉编址）。

15. 关于存储器读写的问题

    * 现在，寄存器可以既读又写，这里会有数据访问风险。（读后写，写后读？）
      * 解决：
        * 借用D触发器的逻辑来改造R、W信号，使之互斥。
        * R/W合并为 WE（write enable）信号，并增加 CS 信号。
        * 之前的R、W可以同时访问。现在R、W只能单独访问。
        * 片选无效时，读写都是高阻，不能工作。片选有效时，只能读或写。

16. ALU和半自动加法机

    * 目前ALU只有加法和减法两种OP

17. 全自动加法机

    * 实现了电源开关。
    * 时钟下降沿取数据，上升沿计算结果并存入。

18. 程序计数器和内存

19.  微程序控制

    * CPU的控制系统分为：微程序、硬布线。微程序较简单。
    * 实验任务：将内存地址1内的3读入寄存器A，将内存地址2内的4读入寄存器B，相加后将7存入寄存器C，再从寄存器C存入内存。

20. 逻辑运算

    * 8AND, 8OR, 8XOR, 8NOT

21. 程序状态字

    * ALU支持的操作：ADD,SUB, AND, OR, XOR, NOT
    * OP由1位变为3位，可区分8种状态。需要38译码器
    * PSW只支持三位，这些位可用于条件状态转移。
      * 溢出：加法溢出，或减法溢出
      * 零位：运算结果为零
      * 奇偶位：有奇数个1

22. 指令系统

    * 作者介绍了一种指令系统，以及汇编指令编译器

23. 寄存器控制器

    * 5到32的Decoder译码器
    * 寄存器控制器，输入是：要读写的寄存器编号；输出是：CS、WE信号。
      * 当读写寄存器编号不同时，则读信号为'b10，写信号为'b11。
      * 当读写寄存器编号相同时，信号是'b01（CS无效）。

24. CPU框架

    * 寄存器的控制端有 CS、WE 两个信号，汇总为2位的一根线，简洁。
    * PC原先的 EN、CS、WE合并为3位的一根信号线。bit2:EN, bit1:CS, bit0:WE

25. CPU控制器

26. 取指令微程序

    * 用ROM来实现，2^16个（64K个）32bit的存储单元。

27. MOV指令

28. 汇编编译器

29. 数据传送指令

    * 微程序， micro.bin，负责将取值、汇编指令翻译为微控制指令。
      * 用ROM来保持微程序，共 64K个32bit的存储单元，64K个是2^16。
      * 换言之，每个存储单元是32bit，连续16个存储单元，是一个微程序。
      * 这16个存储单元所存储的微程序，包括了取值、译码、执行等多个阶段。
        * 取值，占用6个单元，每段微程序都是一样的。
        * 译码和执行跟在后面，可能以后包括更多动作。
      * 每个汇编指令被编码为三个字节：操作码，目的操作数，源操作数。
        * 微程序的前6步：取【操作码、DST、SRC】各两步。
        * 微程序的后续步骤，与各个汇编指令有关了。
        * 总之，微程序是控制“CU”的。
    * 汇编程序，program.bin，上层的用户逻辑。

30. 算术运算指令

    * 中央处理器 —— 硬布线控制器和微程序控制器

      https://blog.csdn.net/starter_____/article/details/98736854

31. 
